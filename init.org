#+Title: Emacs Config
#+Author: jlindsey
#+Description: My init.el
#+PROPERTY: header-args:emacs-lisp :tangle ./init.el :mkdirp yes :comments no
#+Startup: showeverything
#+Options: toc:3

#+begin_src emacs-lisp
    ;;; init.el -- tangled from init.org -*- lexical-binding: t -*-
#+end_src

*  Contents :toc_3:
- [[#intro][Intro]]
- [[#core-setup][Core Setup]]
  - [[#auto-tangle-hook][Auto-tangle Hook]]
  - [[#package-manager][Package manager]]
    - [[#repos][Repos]]
    - [[#straight][Straight]]
    - [[#helpers][Helpers]]
  - [[#emacs-defaults][Emacs Defaults]]
  - [[#savehist][Savehist]]
  - [[#evil-][Evil ðŸ˜ˆ]]
- [[#keybinds][Keybinds]]
- [[#org][Org]]
- [[#ui][UI]]
  - [[#theme][Theme]]
  - [[#modeline][Modeline]]
  - [[#nerd-icons][Nerd Icons]]
  - [[#dashboard][Dashboard]]
  - [[#popup-management][Popup Management]]
    - [[#shackle][Shackle]]
    - [[#popper][Popper]]
    - [[#solaire][Solaire]]
  - [[#misc][Misc]]
    - [[#macos][MacOS]]
- [[#help][Help]]
  - [[#helpful][Helpful]]
  - [[#flycheck][Flycheck]]
  - [[#which-key][Which-key]]
- [[#project-management][Project Management]]
  - [[#treemacs][Treemacs]]
- [[#completion][Completion]]
  - [[#corfu][Corfu]]
  - [[#cape][Cape]]
  - [[#vertico][Vertico]]
    - [[#marginalia][Marginalia]]
  - [[#yasnippet][Yasnippet]]
  - [[#consult][Consult]]
  - [[#orderless][Orderless]]
- [[#lsp][LSP]]
- [[#treesitter][Treesitter]]
- [[#languages][Languages]]
  - [[#markdown][Markdown]]
  - [[#elisp][Elisp]]
  - [[#go][Go]]
  - [[#python][Python]]
  - [[#yaml][YAML]]
    - [[#ansible][Ansible]]
- [[#misc-1][Misc]]
- [[#performance-and-finalize][Performance and Finalize]]

* Intro
This config is written in Org Babel with a literate style to make it easier to navigate and annotate. The "real" init is
therefore in ~init.org~ and you should avoid editing the derived ~init.el~ directly. A hook is provided to automatically
tangle the code blocks into ~init.el~ on save. If you need (for example on an error that prevents the hook) you can
manually tangle with ~C-c C-v t~.

At a high level: I use ~evil-mode~ exclusively, and prefer a non-chorded interaction style a la Doom and
Spacemacs. IDE-like features are mainly drawn from LSP mode, with Corfu/Vertico/Cape used for autocomplete.

Much inspiration taken from:
+ https://github.com/MiniApollo/kickstart.emacs
+ https://github.com/doomemacs/doomemacs
+ https://www.spacemacs.org/ 

* Core Setup
Make startup faster by reducing the frequency of garbage collection. This will be set back when startup finishes.
#+begin_src emacs-lisp
    ;; The default is 800 kilobytes. Measured in bytes.
    (setq gc-cons-threshold (* 50 1000 1000))
#+end_src

Update load path for personal libraries etc. We're not doing any ~autoload~ magic here at the moment.
#+begin_src emacs-lisp
    (add-to-list 'load-path (expand-file-name "lisp" user-emacs-directory))
    (require 'project-indicators)
#+end_src

** Auto-tangle Hook
#+begin_src emacs-lisp
    (defun start/org-babel-tangle-config ()
      "Automatically tangle our init.org config file"
      (interactive)
      (when (string-equal (file-name-directory (buffer-file-name))
                          (expand-file-name user-emacs-directory))
        (let ((org-confirm-babel-evaluate nil))
          (org-babel-tangle))))

    (add-hook 'org-mode-hook (lambda () (add-hook 'after-save-hook #'start/org-babel-tangle-config)))
#+end_src

** Package manager
I use ~straight.el~ as the package manager.

*** Repos
Set repo lists

#+begin_src emacs-lisp
    (setq package-archives '(("melpa" . "https://melpa.org/packages/")
                             ("org" . "https://orgmode.org/elpa/")
                             ("elpa" . "https://elpa.gnu.org/packages/")
                             ("nongnu" . "https://elpa.nongnu.org/nongnu/")))
#+end_src

*** Straight
I use ~straight.el~ instead of ~package.el~ for the ability to do rollbacks and easily use Github et al sources instead
of just the repos. It's set up to use normal ~use-package~ forms; the one difference to remember is that if you don't
want a given package installed (that is: you want to use ~use-package~ as a way to ~require~ built-in packages like Org
with the ability to also set hooks etc) then ~:ensure nil~ must be used with ~:straight nil~.

In ~early-init.el~ we set ~package-enable-at-startup nil~. It is the only thing in that file. We also set that variable
here, mainly in order to make it easier to run Emacs in batch mode to update / freeze / thaw the packages in a script.

#+begin_src emacs-lisp
    (setq package-enable-at-startup nil ;; also set in early-init.el
          straight-use-package-version 'straight
          straight-use-package-by-default t)

    (defvar bootstrap-version)

    (let ((bootstrap-file
           (expand-file-name
            "straight/repos/straight.el/bootstrap.el"
            (or (bound-and-true-p straight-base-dir)
                user-emacs-directory)))
          (bootstrap-version 7))
      (unless (file-exists-p bootstrap-file)
        (with-current-buffer
    		(url-retrieve-synchronously
             "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
             'silent 'inhibit-cookies)
          (goto-char (point-max))
          (eval-print-last-sexp)))
      (load bootstrap-file nil 'nomessage))
#+end_src


*** Helpers
Define a couple helpers here to manage Straight. Bound later on.

#+begin_src emacs-lisp
    (defun straight/cleanup ()
      "Prunes cache and build dirs, and purges unused repos"
      (interactive)
      (straight-prune-build)
      (straight-remove-unused-repos t))

    (defun straight/update ()
      "Pulls and updates all packages"
      (interactive)
      (straight-pull-recipe-repositories)
      (straight-pull-all))
#+end_src

** Emacs Defaults
Configure baseline Emacs defaults.

#+begin_src emacs-lisp
    (use-package emacs
      :custom
    	;; Enable these for Vertico
      (context-menu-mode t)
      (enable-recursive-minibuffers t)

    	;; Turn off all the window chrome
      (menu-bar-mode nil)
      (scroll-bar-mode nil)
      (tool-bar-mode nil)

      (delete-selection-mode t)
      (electric-indent-mode t)
      (electric-pair-mode nil)

      (blink-cursor-mode nil)
      (global-auto-revert-mode t)

      (fill-column 120) ;; Using evil's Vgq to format paragraphs, wrap on col 120
      (tab-width 4)
      (line-spacing 0.12)

      (make-backup-files nil) ;; Do not make ~ files
      (auto-save-default nil) ;; Do not make # files

      ;; Hide commands in M-x which do not work in the current mode.
      (read-extended-command-predicate #'command-completion-default-include-p)
      ;; Do not allow the cursor in the minibuffer prompt
      (minibuffer-prompt-properties '(readonly t cursor-intangible t face minibuffer-prompt))

      :config
      (set-face-attribute
       'default nil
       :family "Hack"
       :height 125
       :weight 'medium)

      :hook
      ; hide minor modes
      (prog-mode . (lambda () (hs-minor-mode t)))
      
      ; enable line numbers but not globally
      (prog-mode . display-line-numbers-mode)
      (text-mode . display-line-numbers-mode)
      (conf-mode . display-line-numbers-mode)

      :bind
      (([escape] . keyboard-escape-quit)))
    #+end_src

** Savehist
Persists various selection and file histories to a file, to be restored on startup. Core Emacs built-in, but must be
used and enabled. By default, saves to ~$HOME/.config/emacs/history~.

#+begin_src emacs-lisp
    (use-package savehist
      :ensure nil
      :init (savehist-mode))
#+end_src

** Evil ðŸ˜ˆ
Setup Evil mode and associated plugins.

#+begin_src emacs-lisp
    (use-package evil
      :init
      (evil-mode)
      :custom
      (evil-want-keybinding nil)
      (evil-want-C-u-scroll t)
      (evil-want-C-i-jump nil)
      (evil-undo-system 'undo-redo)
      (evil-visual-update-x-selection-p nil)
      :config
      (add-hook 'after-change-major-mode-hook (lambda () (setq-local evil-shift-width tab-width))))
#+end_src

Include ~evil-collection~, which is a set of keymaps and bindings for special buffer types like ~help-mode~ and
~dired~. I set it up as an explicit whitelist rather than letting it default to trying to remap everything it knows
about. Note that this means you need to update this list whenever a package is added with a new mode.
#+begin_src emacs-lisp
    (use-package evil-collection
      :after evil
      :config
      (setq evil-collection-mode-list '(dired ibuffer magit corfu vertico consult info
    										  help helpful compilation flycheck))
      (evil-collection-init))
#+end_src

~evil-surround~ is a port of tpope's ~vim-surround~ which provides mappings to easily surround a text object with pairs of quotes, parens, brackets, etc.
#+begin_src emacs-lisp
    (use-package evil-surround
      :after evil
      :config (global-evil-surround-mode 1))
#+end_src

~evil-lion~ ports ~vim-lion~, for easy line alignment motions.
#+begin_src emacs-lisp
    (use-package evil-lion
      :after evil
      :config (evil-lion-mode))
#+end_src

~evil-escape~ universalizes escaping in all types of buffers. I bind it to ~C-g~ as a global "cancel".
#+begin_src emacs-lisp
    (use-package evil-escape
      :after evil
      :custom
      (evil-escape-excluded-states '(normal visual multiedit emacs motion))
      (evil-escape-excluded-major-modes '(treemacs-mode))
      (evil-escape-key-sequence nil)
      (evil-escape-delay 0.15)
      :init
      (evil-escape-mode)
      (evil-define-key* '(insert replace visual operator) 'global "\C-g" #'evil-escape)
      :config
      ;; `evil-escape' in the minibuffer is more disruptive than helpful. That is,
      ;; unless we have `evil-collection-setup-minibuffer' enabled, in which case we
      ;; want the same behavior in insert mode as we do in normal buffers.
      (add-hook 'evil-escape-inhibit-functions
    			(defun my/evil-inhibit-escape-in-minibuffer-fn ()
    			  (and (minibufferp)
    				   (or (not (bound-and-true-p evil-collection-setup-minibuffer))
    					   (evil-normal-state-p))))))
#+end_src

* Keybinds
This config uses ~general~ for keybind management because:
+ I prefer the doom/spacemacs single leader key style, and it makes this easy to set up
+ It supports using ~use-package~ to set up keys at the point where they are most relevent
          
Given that second point, only keys which aren't associated with a particular package should be set here. Things like
window split management and movement, quitting/restarting, etc. Top-level "categories" are also set, although they may
be empty here and added to later on. Package-specific bindings should use the ~:general~ form in ~use-package~.

#+begin_src emacs-lisp
    (use-package general
      :custom
      (general-use-package-emit-autoloads t)
      :config
      (general-evil-setup)
      
      (general-define-key
       :states '(visual)
       "s-/" 'comment-or-uncomment-region)

      (general-define-key
       :states '(normal)
       "s-/" 'comment-line)

      (general-define-key
       :states '(normal)
       "g t" 'tab-line-switch-to-next-tab
       "g T" 'tab-line-switch-to-prev-tab)

      (general-create-definer start/leader-keys
    	:states '(normal emacs)
    	:keymaps 'override
    	:prefix "SPC"
    	:global-prefix "SPC")
      
      (start/leader-keys
    	"SPC" '(find-file :wk "Find file")
    	":" '(execute-extended-command :wk "M-x")
    	"TAB" '(treemacs-select-window :wk "Treemacs"))

      (start/leader-keys
    	"~" '(:ignore t :wk "Straight")
    	"~ c" '(straight/cleanup :wk "Cleanup")
    	"~ u" '(straight/update :wk "Update")
    	"~ f" 'straight-freeze-versions
    	"~ t" `straight-thaw-versions)
      
      (start/leader-keys
    	"b" '(:ignore t :wk "Buffers")
    	"b i" '(ibuffer :wk "ibuffer")
    	"b d" '(evil-delete-buffer :wk "Delete buffer"))
      
      (start/leader-keys
    	"C" '(:ignore t :wk "Configs")
    	"C i" '((lambda () (interactive) (find-file "~/.config/emacs/init.org")) :wk "Edit init.org")
    	"C e" '((lambda () (interactive) (find-file "~/.config/emacs/early-init.el")) :wk "Edit early-init.el")
    	"C r" '((lambda () (interactive) (load-file "~/.config/emacs/init.el")) :wk "Reload init.el"))

      (start/leader-keys
    	"l" '(:ignore t :wk "LSP"))

      (start/leader-keys
    	"q" '(:ignore t :wk "Quit")
    	"q r" '(restart-emacs :wk "Restart")
    	"q q" '(evil-quit-all :wk "Quit All"))

      (start/leader-keys
    	"t" '(:ignore t :wk "Toggles")
    	"t f" 'toggle-frame-fullscreen
    	"t t" 'tab-line-mode)
      
      (start/leader-keys
    	"w" '(:ignore t :wk "Windows / Splits")
    	"w s" 'evil-window-split
    	"w v" 'evil-window-vsplit
    	"w S" 'evil-window-new
    	"w V" 'evil-window-vnew
    	"w h" 'evil-window-left
    	"w j" 'evil-window-down
    	"w k" 'evil-window-up
    	"w l" 'evil-window-right
    	"w H" 'evil-window-move-far-left
    	"w J" 'evil-window-move-very-bottom
    	"w K" 'evil-window-move-very-top
    	"w L" 'evil-window-move-far-right)
      )
#+end_src

* Org
I don't use Org mode much except for this config, so just set up a couple simple packages and configs here.

#+begin_src emacs-lisp
    (use-package org
      :ensure nil
      :straight nil
      :custom
      (org-edit-src-content-indentation 4)
      (org-return-follows-link t)
      :hook
      ((org-mode . org-indent-mode)
       (org-mode . my/set-literate-init-capfs))
      :init
      (defun my/set-literate-init-capfs ()
    	(setq-local completion-at-point-functions
    				(list #'cape-elisp-block #'cape-file #'cape-keyword #'cape-dabbrev))))
#+end_src

Automatically manage the table of contents at the beginning of this file based on headings:
#+begin_src emacs-lisp
    (use-package toc-org
      :commands toc-org-enable
      :hook (org-mode . toc-org-mode))
#+end_src

A built-in Emacs Org package that provides org-mode templates. For our purposes here, it lets you type ~<s TAB~ to make
a source code block.
#+begin_src emacs-lisp
    (use-package org-tempo
      :ensure nil
      :straight nil
      :after org)
#+end_src

Make it look a bit prettier:
#+begin_src emacs-lisp
    (use-package org-superstar
      :after org
      :hook (org-mode . org-superstar-mode))
#+end_src


* UI
Various UI customizations like theme, modeline, etc

** Theme
Use ~doom-themes~, which is a theme collection package. Nice to be able to switch sometimes.

#+begin_src emacs-lisp
    (use-package doom-themes
      :custom
      (doom-themes-enable-bold t)
      (doom-themes-enable-italic t)
      (doom-themes-treemacs-theme "doom-colors")
      :config
      (load-theme 'doom-material t)
      (doom-themes-visual-bell-config)
      (doom-themes-treemacs-config))
#+end_src

** Modeline
Use ~doom-modeline~ instead of the default, which is minimal enough while still having lots of functionality and interop
with other packages like Flycheck and LSP.

#+begin_src emacs-lisp
    (use-package doom-modeline
      :custom
      (doom-modeline-height 25)
      (doom-modeline-total-line-number t)
      (doom-modeline-project-name t)
      :hook (after-init . doom-modeline-mode))
#+end_src

** Nerd Icons
Use Nerd Icons everywhere we can. Here is where we put the base ~nerd-icons~ package as well as the integrations with
core modes like Dired and Ibuffer. Integrations with other packages like Treemacs and Corfu are in those sections.

#+begin_src emacs-lisp
    (use-package nerd-icons
      :if (display-graphic-p))

    (use-package nerd-icons-dired
      :hook (dired-mode . (lambda () (nerd-icons-dired-mode t))))

    (use-package nerd-icons-ibuffer
      :hook (ibuffer-mode . nerd-icons-ibuffer-mode))
#+end_src

** Dashboard
A nice startup screen showing recent files, projects, etc.

#+begin_src emacs-lisp
    (use-package dashboard
      :custom
      (dashboard-startup-banner 'logo)
      (dashboard-projects-backed 'project-el)
      (dashboard-center-content t)
      (dashboard-vertically-center-content t)
      (dashboard-navigation-cycle t)
      (dashboard-display-icons t)
      (dashboard-icon-type 'nerd-icons)
      (dashboard-set-heading-icons t)
      (dashboard-set-file-icons t)
      :init
      (setq dashboard-items '((recents . 10)
    						  (projects . 5)))
      :config (dashboard-setup-startup-hook))
#+end_src

Required for the section dividers:
#+begin_src emacs-lisp
    (use-package page-break-lines
      :init (page-break-lines-mode))
#+end_src

** Popup Management
Emacs makes lots of different windows and buffer types that are essentially ephemeral: ~helpful-mode~, Flycheck,
Warnings, Messages, etc. The packages and configs here help to manage them in a less annoying way.

*** Shackle
Set rules for how these kinds of windows are displayed: size, position alignment, whether they steal focus, etc.

#+begin_src emacs-lisp
    (use-package shackle
      :config
      (setq shackle-rules
            '(
              (("\\*Help\\*" helpful-mode) :align right :size 0.35 :select nil)
    		  (lsp-help-mode :align right :size 0.35 :select nil)

    		  ("\\*compilation\\*" :align below :size 0.25 :noselect t)
    		  (("\\*Flycheck errors\\*" flycheck-error-list-mode) :align below :size 0.25 :select t)
    		  (("\\*Warnings\\*" special-mode) :align below :size 0.2 :select nil)

    		  ("\\*Messages\\*" :align below :size 0.3 :select nil)
    		  ("\\*Backtrace\\*" :align below :size 0.3 :select t))
    		)
      (shackle-mode 1))
#+end_src

*** Popper
Manager for "popup" windows. Matching window names or buffer modes are treated as inferior, easily dismissable, and
toggleable. You can cycle through these kinds of windows, list them all, group them by project, etc.

#+begin_src emacs-lisp
    (use-package popper
      :custom
      (popper-display-control nil)
      (popper-group-function #'popper-group-by-project)
      (popper-mode-line nil)

      :init
      (setq popper-reference-buffers
            '("\\*Messages\\*"
              "\\*Warnings\\*"
    		  "\\*Info\\*"
              "Output\\*$"
              "\\*Async Shell Command\\*"
              "\\*Flycheck errors\\*"
              "\\*helpful.*\\*"
    		  Info-mode
              special-mode
              help-mode
    		  lsp-help-mode
              compilation-mode))

      :config
      (popper-mode +1)
      (popper-echo-mode +1)

      :general
      (start/leader-keys
    	"w q" 'popper-kill-latest-popup
    	"w p" 'popper-toggle
    	"w TAB" 'popper-cycle))
#+end_src

*** Solaire
De-emphasize these kinds of windows by dimming their background.
#+begin_src emacs-lisp
    (use-package solaire-mode
      :hook (after-init . solaire-global-mode))
#+end_src

** Misc
Several minor UI packages that don't need their own TOC heading.

Highlight the current line:
#+begin_src emacs-lisp
    (use-package hl-line
      :ensure nil
      :straight nil
      :hook (after-init . global-hl-line-mode))
#+end_src

*** MacOS
Set a few variables for better experience on Mac
#+begin_src emacs-lisp
    ;; MacOS UI improvements
    (setq
     ns-use-native-fullscreen nil
     mac-redisplay-dont-reset-vscroll t
     mac-mouse-wheel-smooth-scroll nil
     delete-by-moving-to-trash t)

#+end_src

On Mac, make the title bar match the current theme:
#+begin_src emacs-lisp
    (use-package ns-auto-titlebar
      :if (eq system-type 'darwin)
      :init (ns-auto-titlebar-mode +1))
#+end_src



* Help
Several packages for use in getting help or otherwise displaying documentation

** Helpful
Ability to lookup key bindings, Emacs functions, variables, all kinds of things. Along with an enhanced ~help-mode~
buffer UI.

#+begin_src emacs-lisp
    (use-package helpful
      :general
      (start/leader-keys
        "h" '(:ignore t :wk "Help")
        "h h" 'helpful-at-point
        "h c" 'helpful-command
        "h f" 'helpful-callable
        "h k" 'helpful-key
        "h v" 'helpful-variable))
#+end_src

** Flycheck
An alternative to the Emacs-native Flybuild that's a bit more full-featured and has good integration with lsp-mode.

#+begin_src emacs-lisp
(use-package flycheck
  :init (global-flycheck-mode))
#+end_src

** Which-key
A built-in package (as of 30) that displays a list of keybindings along the bottom in the minibuffer after a short delay
when you start a chord or leader sequence.

#+begin_src emacs-lisp
    (use-package which-key
      :ensure nil
      :init (which-key-mode 1)
      :custom
      (which-key-side-window-location 'bottom)
      (which-key-sort-order #'which-key-key-order-alpha)
      (which-key-sort-uppercase-first nil)
      (which-key-add-column-padding 1)
      (which-key-min-display-lines 5)
      (which-key-idle-delay 0.5)
      (which-key-max-description-length 35)
      (which-key-allow-imprecise-window-fit nil))
#+end_src


* Project Management
For now, use ~project.el~ for project management, with a few plugins for interop.

#+begin_src emacs-lisp
    (use-package project
      :straight nil
      :ensure nil
      :general
      (start/leader-keys
    	"p" '(:ignore t :wk "Projects")
    	"p p" 'project-switch-project
    	"p f" 'project-find-file))
#+end_src

Separate ibuffer lists into projects.
#+begin_src emacs-lisp
    (use-package ibuffer-project
      :init
      (defun my/ibuffer-project-filter-predicate ()
    	(setq ibuffer-filter-groups (ibuffer-project-generate-filter-groups))
    	(unless (eq ibuffer-sorting-mode 'project-file-relative)
    	  (ibuffer-do-sort-by-project-file-relative)))
      :hook (ibuffer . my/ibuffer-project-filter-predicate))
#+end_src

** Treemacs
Having a top-down filesystem view of your project is handy. We use a couple different plugins for this.

Note that ~project.el~ compatibility is built-in; the ~project-treemacs~ project on MELPA uses Treemacs for project root
definitions and only works while the Treemacs buffer is open; not a great UX.

#+begin_src emacs-lisp
    (use-package treemacs
      :custom
      (treemacs-width 30)
      (treemacs-follow-after-init t)
      (treemacs-sotring 'alphabetic-case-insensitive-asc)
      (treemacs-indent-guide-style 'line)
      (treemacs-is-never-other-window nil)
      :config
      (treemacs-project-follow-mode t)
      (treemacs-fringe-indicator-mode 'always)
      (treemacs-git-mode 'deferred)
      (treemacs-git-commit-diff-mode t)
      (treemacs-indent-guide-mode t))
#+end_src
   
Evil integration plugin
#+begin_src emacs-lisp
    (use-package treemacs-evil
      :after treemacs)
#+end_src

Add icons to the file lists
#+begin_src emacs-lisp
    (use-package treemacs-nerd-icons
      :after treemacs
      :config (treemacs-load-theme 'nerd-icons))
#+end_src

* Completion
Packages for auto-complete and CAPF management. In general I use LSP mode for completions in most cases, but with its
CAPF deferred to Corfu. Vertico is used for minibuffer completion.

There are a lot of different packages managed here and it's not always clear exactly what each thing does: the packages
here are designed to be minimalst and single-purpose. Contrast this with eg Company, which is both a completion backend
and a popup UI element. I've tried to leave good descriptions around each one and describe how they work together.

** Corfu
This is the primary ~completion-at-point~ UI. It calls CAPFs and displays their outputs, allowing you to filter, search,
and select from them. It does not provide any completion backends on its own. For that we use both Cape and LSP.

#+begin_src emacs-lisp
    (use-package corfu
      :init
      (global-corfu-mode)
      (corfu-popupinfo-mode)
      (corfu-history-mode)

      :custom
      (corfu-cycle t)
      (corfu-auto t)
      (corfu-auto-prefix 2)
      (corfu-auto-delay 0.1)
      (corfu-separator ?\s)
      (corfu-popupinfo-delay 0.1)
      (corfu-preselect 'prompt)
      (completion-ignore-case t)
      (text-mode-ispell-word-completion nil)
      (tab-always-indent 'complete)

      :general
      (general-define-key
       :states '(normal insert)
       "C-SPC" 'completion-at-point))
#+end_src

Adds nerd-icons to Corfu based on the type of thing being completed (variable, function, file, etc)
#+begin_src emacs-lisp
    (use-package nerd-icons-corfu
      :after corfu
      :init (add-to-list 'corfu-margin-formatters #'nerd-icons-corfu-formatter))
#+end_src

** Cape
Completion-at-point extensions library, which provides both a couple useful built-in CAPFs and several functions to
compose and transform other CAPFs. Notably includes the ability to adapt company backends to generic CAPFs that Corfu
can use.

#+begin_src emacs-lisp
    (use-package cape
      :after corfu
      :init
      (add-hook 'completion-at-point-functions #'cape-file)
      (add-hook 'completion-at-point-functions #'cape-keyword)
      :general
      (start/leader-keys
        "a" '(cape-prefix-map :wk "Cape")))
#+end_src

** Vertico
Whereas Corfu handles ~completion-at-point-functions~, Vertico handles ~completing-read~ (in-buffer vs minibuffer
completions). Vertico handles things like listing history and candidates for ~M-x~, searching for files with
~find-file~, etc. Rule of thumb: anything that pops up at the bottom of the screen uses this.

Vertico also interacts with Consult: Vertico is the display, Consult is the backend.

#+begin_src emacs-lisp
    (use-package vertico
      :custom
      (vertico-scroll-margin 5)
      (vertico-count 15)
      (vertico-resize nil)
      (vertico-cycle t)
      :init
      (vertico-mode))
#+end_src

*** Marginalia
Adds help and descriptions to the right of autocomplete suggestions in Vertico:

#+begin_src emacs-lisp
    (use-package marginalia
      :after vertico
      :bind (:map minibuffer-local-map
    			  ("M-A" . marginalia-cycle))
      :init (marginalia-mode))
#+end_src

Also adds nerd-icons to suggestions based on their type:
#+begin_src emacs-lisp
    (use-package nerd-icons-completion
      :after marginalia
      :config (nerd-icons-completion-mode)
      :hook (marginalia-mode . nerd-icons-completion-marginalia-setup))
#+end_src

** Yasnippet
Framework for creating and inserting templated snippets as completions.

#+begin_src emacs-lisp
    (use-package yasnippet
      :after cape
      :config (yas-global-mode 1))
#+end_src

The CAPF functionality is a separate package:

#+begin_src emacs-lisp
    (use-package yasnippet-capf
      :after (cape lsp))
#+end_src

Install the omnibus library of different premade snippets:
#+begin_src emacs-lisp
    (use-package yasnippet-snippets
      :after yasnippet
      :config (yas-reload-all))
#+end_src

** Consult
Provides a series of ~completing-read~ backends; in other words, it is to Vertico what Cape is to Corfu. Also adds
descriptions compatible with Marginalia. It has a lot of different functions for things like looking up buffers, listing
files, finding things (via ~rg~ or ~fd~, or lines within a file, etc). Most of the functions can also be scoped to the
current project.

#+begin_src emacs-lisp
    (use-package consult
      :custom
      (register-preview-delay 0.3)
      (register-preview-function #'consult-register-format)
      (xref-show-xrefs-function #'consult-xref)
      (xref-show-definitions-function #'consult-xref)
      :init
      (advice-add #'register-preview :override #'consult-register-window)
      :hook
      (completion-list-mode . consult-preview-at-point-mode)
      :general
      (start/leader-keys
        "s" '(:ignore t :wk "Search")
        "s b" 'consult-buffer
        "s r" 'consult-recent-file
        "s f" 'consult-fd
        "s g" 'consult-ripgrep
        "s l" 'consult-line
        "s i" 'consult-imenu))
#+end_src

** Orderless
A better way of searching through completion candidates in both modes. The search pattern is divided into
space-separated components, and then candidates are matched against them in any order.

#+begin_src emacs-lisp
    (use-package orderless
      :custom
      (completion-styles '(orderless basic))
      (completion-category-overrides `((file (styles basic partial-completion)))))
#+end_src

* LSP
I used to use Eglot but switched to LSP mode for two specific reasons:
+ I want the ability to run multiple servers per buffer / file type (eg. running both ~pyright~ and ~ruff~ in Python)
+ LSP mode has better integration with several things like Treemacs

LSP mode brings along its own autocomplete UI that will compete with Corfu unless disabled; you also need to write a
small glue function to get them to talk nicely to one another.

Note that ~(lsp-mode)~ isn't called here. I prefer to have the individual languages set their own hooks.

#+begin_src emacs-lisp
    (use-package lsp-mode
      :custom
      (lsp-completion-provider :none)
      (lsp-completion-enable t)
      (lsp-completion-default-behavior :insert)
      :hook
      ((lsp-mode . lsp-enable-which-key-integration)
       (lsp-completion-mode . my/lsp-mode-setup-completion))
      :config
      (defun my/lsp-mode-setup-completion ()
        (setf (alist-get 'styles (alist-get 'lsp-capf completion-category-defaults))
              '(orderless))
    	(setq-local completion-at-point-functions
    				(list (cape-capf-super #'lsp-completion-at-point #'yasnippet-capf)))))
#+end_src

Also enable the Treemacs integration plugin:

#+begin_src emacs-lisp
    (use-package lsp-treemacs
      :config
      (lsp-treemacs-sync-mode 1)
      :general
      (start/leader-keys
    	"l t s" 'lsp-treemacs-symbols
    	"l t r" 'lsp-treemacs-references
    	"l t i" 'lsp-treemacs-implementations
    	"l t c" 'lsp-treemacs-call-hierarchy
    	"l t t" 'lsp-treemacs-type-hierarchy))
#+end_src

Also enable UI plugin:

#+begin_src emacs-lisp
    (use-package lsp-ui
      :hook (lsp-mode . lsp-ui-mode))
#+end_src

* Treesitter
Use ~tree-sitter~ for better and faster syntax parsing and highlighting. Works well with ~indent-bars-mode~.

#+begin_src emacs-lisp
    (use-package treesit-auto
      :custom
      (treesit-auto-install 'prompt)
      :config
      (treesit-auto-add-to-auto-mode-alist 'all)
      (global-treesit-auto-mode))
#+end_src

NOTE: This package automatically sets ~auto-mode-alist~, remapping major modes to their Treesitter versions (eg
~python-mode~ -> ~python-ts-mode~). For some, like Python, this means you need to use the shared ~python-base-mode~ for
hooks etc. Others don't have this shared base mode and so to avoid breaking hooks you need to shadow the hook
definition. I do this in the base major mode package's ~:init~ section; see Go below for an example.

* Languages
Modes and packages for writing specific languages. I use LSP mode as the primary way of generating completions /
"IntelliSense"-like behavior, and to augment other language-specific packages. Each "main" language package here is
responsible for enabling LSP mode on its own if it wants to.

** Markdown
Everybody's favorite README language. Default to Github-flavored markdown mode.

#+begin_src emacs-lisp
    (use-package markdown-mode
      :mode ("/README\\(?:\\.md\\)?\\'" . gfm-mode)
      :custom
      (markdown-italic-underscore t)
      (markdown-gfm-additional-languages '("sh"))
      (markdown-make-gfm-checkboxes-buttons t)
      (markdown-fontify-whole-heading-line t)
      (markdown-fontify-code-blocks-natively t))
#+end_src

** Elisp
Emacs lisp mode hooks

#+begin_src emacs-lisp
    (use-package emacs-lisp-mode
      :straight nil
      :ensure nil
      :hook (emacs-lisp-mode . my/set-elisp-capfs)
      :init
      (defun my/set-elisp-capfs ()
    	(setq-local completion-at-point-functions 
    				(list #'cape-elisp-symbol #'cape-file #'cape-keyword #'cape-dabbrev))))
#+end_src

Highlight quotes in elisp files

#+begin_src emacs-lisp
    (use-package highlight-quoted
      :hook (emacs-lisp-mode . highlight-quoted-mode))
#+end_src

** Go
Program in Go with LSP support from ~gopls~:

#+begin_src emacs-lisp
    (use-package go-mode
      :init (setq go-ts-mode-hook go-mode-hook)
      :mode "\\.go\\'"
      :hook (go-mode . lsp-deferred))
#+end_src

Use ~golangci-lint~ for static checks:

#+begin_notes
12-15-2025: Disable until https://github.com/weijiangan/flycheck-golangci-lint/issues/20 is fixed
#+end_notes

#+begin_src emacs-lisp :tangle no
    (use-package flycheck-golangci-lint
      :hook (go-mode . flycheck-golangci-lint-setup))
#+end_src

** Python
Set up ~python-mode~ hooks and LSP integration (nb. this is setting up the Emacs built-in Python mode, not
~python-mode.el~, which I don't use).

#+begin_src emacs-lisp
    (use-package python
      :ensure nil
      :straight nil
      :hook
      ((python-base-mode . lsp-deferred)
       (python-base-mode . (lambda () (highlight-indentation-mode -1))) ; using indent-bars-mode instead
       (python-base-mode . indent-bars-mode)))
#+end_src

Using elpy for the primary Python mode, alongside LSPs

#+begin_src emacs-lisp
    (use-package elpy
      :hook (python-mode . elpy-enable)
      :general
      (general-create-definer python/mode-leader
    	:states '(normal)
    	:keymaps 'python-base-mode-map
    	:prefix "SPC m")
    	
      (python/mode-leader
    	"i" '(:ignore t :wk "Imports")))
#+end_src

Using "basedpyright" for the primary LSP client for its speed and extra features

#+begin_src emacs-lisp
    (use-package lsp-pyright
      :custom (lsp-pyright-langserver-command "basedpyright"))
#+end_src

Import management:

#+begin_src emacs-lisp
    (use-package pyimport
      :commands (pyimport-remove-unused pyimport-insert-missing)
      :general
      (python/mode-leader
    	"i r" 'pyimport-remove-unused
    	"i m" 'pyimport-insert-missing))

    (use-package py-isort
      :commands (py-isort-region py-isort-buffer)
      :general
      (python/mode-leader
    	"i s" 'py-isort-buffer))
#+end_src

Detect and select the correct Python version / venv:
#+begin_src emacs-lisp
    (use-package pet
      :hook (python-base-mode . pet-mode))
#+end_src

** YAML
Generic YAML file highlighting + LSP support

#+begin_src emacs-lisp
    (use-package yaml-mode
      :init (setq yaml-ts-mode-hook yaml-mode-hook)
      :hook
      ((yaml-mode . lsp-deferred)
       (yaml-mode . indent-bars-mode)))
#+end_src

*** Ansible
Specific packages for Ansible support, uses a custom function to determine whether we're in an Ansible project. Note
that this automatically sets lsp-mode to use ~ansible-ls~ and prompt to install it if missing.

#+begin_src emacs-lisp
    (use-package ansible
      :hook (yaml-mode . (lambda () (when (project/is-ansible-project) (ansible-mode 1)))))
#+end_src

* Misc
Various other minor packages that don't fit in the other sections.

Colorize pairs of delimiters (parens, braces, angles, etc):
#+begin_src emacs-lisp
    (use-package rainbow-delimiters
      :hook (prog-mode . rainbow-delimiters-mode))
#+end_src

Automatically trim whitespace from edited lines:
#+begin_src emacs-lisp
    (use-package ws-butler
      :hook (prog-mode . ws-butler-mode))
#+end_src

Automatically format a buffer on save:
#+begin_src emacs-lisp
    (use-package apheleia
      :hook (prog-mode . (lambda () apheleia-global-mode +1))
      :general
      (start/leader-keys
    	"t a" '(apheleia-global-mode :wk "Toggle Apheleia")))
#+end_src

Indentation lines used in several language modes. Note that it isn't enabled here; it should be added to the hooks of
whatever other modes want it.
#+begin_src emacs-lisp
    (use-package indent-bars
      :custom
      (indent-bars-display-on-blank-lines nil)
      (indent-bars-color '(default :face-bg t :blend 0.3))
      (indent-bars-pattern ".")
      (indent-bars-width-frac 0.25)
      (indent-bars-pad-frac 0.1))
#+end_src

Automatically load Direnv into buffer-local config:
#+begin_src emacs-lisp
    (use-package envrc
      :hook (after-init . envrc-global-mode))
#+end_src

* Performance and Finalize
Make GC pauses faster by decreasing the threshold (undoing what we did at the very beginning).
#+begin_src emacs-lisp
    (setq gc-cons-threshold (* 2 1000 1000))
#+end_src

Increase the max amount of data which Emacs reads from the process, leading to slightly less IO churn.
#+begin_src emacs-lisp
    (setq read-process-output-max (* 1024 1024)) ;; 1mb
#+end_src
